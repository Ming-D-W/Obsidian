#### 1.4 垃圾回收机制

**目标：** 了解JS垃圾回收机制的执行过程

**学习目的：** 为了闭包做铺垫

**学习路径：**

1.什么是垃圾回收机制

2.内存的声明周期

3.垃圾回收的算法说明

##### 1.4.1 什么是垃圾回收机制？

垃圾回收机制(Garbage Collection) 简称 GC

JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。 

正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题

但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况

**不再用到的内存，没有及时释放，就叫做内存泄漏**

##### 1.4.2 内存生命周期

JS环境中分配的内存, 一般有如下生命周期： 

1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 

2. 内存使用：即读写内存，也就是使用变量、函数等 

3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 

4. 说明：

   > 全局变量一般不会回收(关闭页面回收)； 
   >
   > 一般情况下局部变量的值, 不用了, 会被自动回收掉
![](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202211221654894.png)

###### 总结

1. 什么是垃圾回收机制？

   > 简称 GC
   >
   > JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被**垃圾回收器**自动回收

2. 什么是内存泄漏？

   > 不再用到的内存，没有及时释放，就叫做内存泄漏

3. 内存的生命周期是什么样的？

   > 内存分配、内存使用、内存回收
   >
   > 全局变量一般不会回收； 一般情况下局部变量的值, 不用了, 会被自动回收掉

##### 1.4.3 垃圾回收算法

​		所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉 

下面介绍两种常见的浏览器垃圾回收算法: **引用计数法** 和 **标记清除法**

###### 1.4.3.1 引用计数法

IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。

算法：  

> 1.跟踪记录每个值被引用的次数。
>
> 2.如果这个值的被引用了一次，那么就记录次数1
>
> 3.多次引用会累加。
>
> 4.如果减少一个引用就减1。
>
> 5.如果引用次数是0 ，则释放内存。	

```js
const person = {
      age: 18,
      name: ‘雪糕老师'
}
const p = person
person = 1
p = null
```

由上面可以看出，引用计数算法是个简单有效的算法。 

但它却存在一个致命的问题：**嵌套引用**。 

如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。如下

```js
function fn() {
    let o1 = {}
    let o2 = {}
    o1.a = o2
    o2.a = o1
    return '引用计数无法回收'
}
fn()
```

因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露

###### 1.4.3.2 标记清除法

现代的浏览器已经不再使用引用计数算法了。 

现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。

核心：

> 1.标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 
>
> 2.就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。
>
> 3.那些无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收。 

![](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202211221654116.png)